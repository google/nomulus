// Copyright 2019 The Nomulus Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package google.registry.monitoring.blackbox;

import static com.google.common.flogger.StackSize.SMALL;
import static google.registry.monitoring.blackbox.Protocol.PROTOCOL_KEY;

import com.google.auto.value.AutoValue;
import com.google.common.collect.ImmutableList;
import com.google.common.flogger.FluentLogger;
import google.registry.monitoring.blackbox.exceptions.InternalException;
import google.registry.monitoring.blackbox.handlers.ActionHandler;
import google.registry.monitoring.blackbox.messages.OutboundMessageType;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelInitializer;
import io.netty.util.AttributeKey;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Iterator;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import org.joda.time.Duration;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.util.HashedWheelTimer;
import io.netty.util.Timer;
import java.util.concurrent.Callable;
import javax.inject.Provider;

/**
 * AutoValue class that represents action generated by {@link ProbingStep}
 *
 * <p> Inherits from {@link Callable<ChannelFuture>}, as it has can be called
 * to perform its specified task, and return the {@link ChannelFuture} that will be informed when the
 * task has been completed </p>
 *
 * <p> Is an immutable class, as it is comprised of the tools necessary for making a specific type of connection.
 * It goes hand in hand with {@link Protocol}, which specifies the kind of overall connection to be made. {@link Protocol}
 * gives the outline and {@link ProbingAction} gives the details of that connection.</p>
 *
 * <p> In its build, if there is no channel supplied, it will create a channel from the attributes already supplied.
 * Then, it only sends the {@link OutboundMessageType} down the pipeline when informed that the connection is successful.
 * If the channel is supplied, the connection future is automatically set to successful.</p>
 */

@AutoValue
public abstract class ProbingAction implements Callable<ChannelFuture> {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /** {@link AttributeKey} in channel that gives the information of the channel's host. */
  public static final AttributeKey<String> REMOTE_ADDRESS_KEY = AttributeKey.valueOf("REMOTE_ADDRESS_KEY");

  /** {@link Timer} that rate limits probing */
  private static final Timer timer = new HashedWheelTimer();

  /** Actual {@link Duration} of this delay */
  public abstract Duration delay();

  /** {@link OutboundMessageType} instance that we write and flush down pipeline to server */
  public abstract OutboundMessageType outboundMessage();

  /** {@link Channel} object that either created by or passed into this {@link ProbingAction} instance */
  public abstract Channel channel();

  /** {@link ChannelFuture} object that is set to success after successful channel connection is established. */
  public abstract ChannelFuture connectionFuture();

  /** The {@link Protocol} instance that specifies type of connection */
  public abstract Protocol protocol();

  /** The hostname of the remote host we have a connection or will make a connection to */
  public abstract String host();

  /** The {@link SocketAddress} instance that specifies remote address of connection */
  @Nullable
  public abstract SocketAddress address();

  /** The {@link Optional<Bootstrap>} that is only used in the {@link Builder} to create a connection. */
  public abstract Optional<Bootstrap> bootstrap();


  public void informListeners(ChannelPromise finished, ActionHandler actionHandler) {
    // Write appropriate outboundMessage to pipeline
    ChannelFuture channelFuture = actionHandler.getFuture();
    channel().writeAndFlush(outboundMessage());
    channelFuture.addListeners(
        //reset the future associated with our ActionHandler in case channel is reused
        future -> actionHandler.resetFuture(),

        //inform ProbingStep of the status of our action
        future -> {
          if (future.isSuccess())
            finished.setSuccess();
          else
            finished.setFailure(future.cause());
        },
        //If we don't have a persistent connection, close the connection to this channel
        future -> {
          if (!protocol().persistentConnection()) {

            ChannelFuture closedFuture = channel().close();
            closedFuture.addListener(
                f -> {
                  if (f.isSuccess())
                    logger.atInfo().log("Closed stale channel. Moving on to next ProbingStep");
                  else
                    logger.atWarning()
                        .log("Could not close channel. Stale connection still exists.");
                }
            );
          }
        }
    );
  }

  /**
   * The method that performs the work of the actual action.
   *
   * <p>First, we establish which of the handlers in the pipeline is the {@link ActionHandler}.
   * From that, we can obtain a future that is marked as a success when we receive an expected
   * response from the server. Then, we send the {@code outboundMessage} down the channel pipeline,
   * and when we observe a success or failure, we inform the {@link ProbingStep} of this.</p>
   *
   * @return {@link ChannelFuture} that denotes when the action has been successfully performed.
   */
  public ChannelFuture performAction() throws InternalException {
    Iterator<Map.Entry<String, ChannelHandler>> handlerIterator = channel().pipeline().iterator();
    ActionHandler actionHandler = null;

    //Finds the ActionHandler from the pipeline and initializes it.
    while (handlerIterator.hasNext()) {
      ChannelHandler currentHandler = handlerIterator.next().getValue();
      if (currentHandler instanceof ActionHandler) {
        actionHandler = (ActionHandler) currentHandler;
        break;
      }
    }

    //If there is no ActionHandler in our pipeline, we have an issue, and throw an InternalException
    if (actionHandler == null) {
      logger.atSevere().withStackTrace(SMALL).log("ActionHandler not in Channel Pipeline");
      throw new InternalException("No Action Handler found in pipeline");
    }

    //ChannelPromise that we use to inform ProbingStep when we are finished.
    ChannelPromise finished = channel().newPromise();

    //Necessary for use of actionHandler in lambda expression
    ActionHandler finalActionHandler = actionHandler;

    //Every specified time frame by delay(), we perform the next action in our sequence and inform ProbingStep when finished
    if (delay() == Duration.ZERO)
      informListeners(finished, finalActionHandler);
    else
      timer.newTimeout(timeout -> informListeners(finished, finalActionHandler),
          delay().getStandardSeconds(),
          TimeUnit.SECONDS);


    return finished;
  }

  /** Method that calls on {@code performAction} when it is certain channel connection is established. */
  @Override
  public ChannelFuture call() throws InternalException {
    //ChannelPromise that we return
    ChannelPromise finished = channel().newPromise();

    //When connection is established call super.call and set returned listener to success
    connectionFuture().addListener(
        (ChannelFuture channelFuture) -> {
          if (channelFuture.isSuccess()) {
            logger.atInfo().log(String
                .format("Successful connection to remote host: %s at port: %d", host(),
                    protocol().port()));
            ChannelFuture future = performAction();
            future.addListener(f -> finished.setSuccess());

          } else {
            //if we receive a failure, log the failure, and close the channel
            logger.atSevere().withCause(channelFuture.cause()).log(
                "Cannot connect to relay channel for %s channel: %s.",
                protocol().name(), this.channel());
            ChannelFuture unusedFuture = channel().close();
          }
        }
    );
    return finished;
  }


  /** {@link AutoValue.Builder} that does work of creating connection when not already present. */
  @AutoValue.Builder
  public abstract static class Builder {

    public abstract Builder setDelay(Duration value);

    public abstract Builder setOutboundMessage(OutboundMessageType value);

    public abstract Builder setProtocol(Protocol value);

    public abstract Builder setHost(String value);

    public abstract Builder setChannel(Channel channel);

    public abstract Builder setAddress(SocketAddress address);

    public abstract Builder setBootstrap(Bootstrap value);

    public abstract Builder setBootstrap(Optional<Bootstrap> value);

    public abstract Builder setConnectionFuture(ChannelFuture future);

    abstract Protocol protocol();

    abstract Channel channel();

    abstract SocketAddress address();

    abstract Optional<Bootstrap> bootstrap();

    abstract String host();

    abstract ProbingAction autoBuild();

    public ProbingAction build() {
      if (address() == null)
        //If no address has been supplied, we set it based on the host and port
        setAddress(new InetSocketAddress(host(), protocol().port()));

      if (protocol().persistentConnection() && channel() != null) {
        //if a channel exists and we want to use it then we don't try to create one
        setConnectionFuture(channel().newSucceededFuture());
      } else {
        //otherwise, we must have a bootstrap present
        assert(bootstrap().isPresent());


        bootstrap().get().handler(
            new ChannelInitializer<Channel>() {
              @Override
              protected void initChannel(Channel outboundChannel)
                  throws Exception {
                //Uses Handlers from Protocol to fill pipeline
                addHandlers(outboundChannel.pipeline(), protocol().handlerProviders());
              }
            })
            .attr(PROTOCOL_KEY, protocol())
            .attr(REMOTE_ADDRESS_KEY, host());

        logger.atInfo().log("Initialized bootstrap with channel Handlers");
        //ChannelFuture that performs action when connection is established
        ChannelFuture connectionFuture = bootstrap().get().connect(address());

        setChannel(connectionFuture.channel());
        setConnectionFuture(connectionFuture);

      }
      //we don't want to actually store Bootstrap, so set its value to Optional.empty()
      setBootstrap(Optional.empty());

      //now we can actually build the ProbingAction
      return autoBuild();
    }
  }

  public static Builder builder() {
    return new AutoValue_ProbingAction.Builder();
  }

  /**
   * Adds provided {@link ChannelHandler}s to the {@link ChannelPipeline} specified
   *
   * @param channelPipeline is pipeline associated with channel that we want to add handlers to
   * @param handlerProviders are a list of provider objects that give us the requisite handlers Adds
   * to the pipeline, the list of handlers in the order specified
   */
  static void addHandlers(
      ChannelPipeline channelPipeline,
      ImmutableList<Provider<? extends ChannelHandler>> handlerProviders) {
    for (Provider<? extends ChannelHandler> handlerProvider : handlerProviders) {
      channelPipeline.addLast(handlerProvider.get());
    }
  }



  @Override
  public String toString() {
    return String.format(
        "ProbingAction with delay: %d\n" +
            "outboundMessage: %s\n" +
            "protocol: %s\n" +
            "host: %s\n",
        delay().getStandardSeconds(),
        outboundMessage(),
        protocol(),
        host()
    );
  }
}
